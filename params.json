{
  "name": "Mirror-based Camera Pose Estimation Using an Orthogonality Constraint",
  "tagline": "",
  "body": "### Introduction\r\nThis page provides an implementation of our mirror-based camera calibration algorithm presented as\r\n```\r\nK. Takahashi, S. Nobuhara and T. Matsuyama: A New Mirror-based Extrinsic Camera Calibration Using an Orthogonality Constraint, CVPR2012\r\n```\r\nand\r\n```\r\nK. Takahashi, S. Nobuhara and T. Matsuyama: Mirror-based Camera Pose Estimation Using an Orthogonality Constraint, IPSJ Transactions on Computer Vision and Applications, Vol.8, pp.11--19, 2016\r\n```\r\n* paper: [CVPR](takahashi12new.pdf) [Journal](http://doi.org/10.2197/ipsjtcva.8.11)\r\n* movie: [mp4](takahashi12new.mp4)\r\n* bibtex:\r\n```\r\n@inproceedings{takahashi12new,\r\n  title = {A New Mirror-based Extrinsic Camera Calibration Using an Orthogonality Constraint},\r\n  author = {Kosuke Takahashi and Shohei Nobuhara and Takashi Matsuyama},\r\n  booktitle = {Proc.\\ of CVPR},\r\n  year = {2012},\r\n}\r\n```\r\nThe motivation of this project is to calibrate a camera w.r.t. a reference object which is not observable from the camera. This happens, for example, in display-camera systems such\r\nas digital signage, webcam attached to laptop PC, etc. Once obtained the mapping between the display pixel coordinate system and the camera coordinate system, it becomes possible to\r\n compute the gazing point (pixel) of a person in front of the display by estimating the gazing direction in the camera coordinate system. This scenario allows the person to move fre\r\nely, while conventional methods typically restrict the head position to be fixed.\r\n\r\nThe key point to solve the problem is the use of mirrored images.\r\nSuppose we have a single static camera $$C$$ and a static reference object $$X$$ as shown below.\r\nThe camera $$C$$ cannot observe the reference object $$X$$ directly.\r\nInstead, we use a mirror $$\\pi$$ and let the camera $$C$$ observe the reference object $$X$$ through it.\r\nThe goal of our mirror-based calibration is to estimate the relative posture $$R$$ and position $$T$$ of the camera $$C$$ against the reference object $$X$$ by observing three point\r\ns of $$X$$ via three mirrors $$\\pi_j (j=1,2,3)$$ under different unknown positions and orientations.\r\n\r\n![Overview](overview.png)\r\n\r\n# Source code\r\n\r\n## License\r\nThis source code is provided under the [BSD 3-Clause license](http://www.opensource.org/licenses/BSD-3-Clause).\r\n```\r\nCopyright (c) 2012, Kosuke Takahashi, Shohei Nobuhara and Takashi Matsuyama\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without\r\nmodification, are permitted provided that the following conditions are met:\r\n   * Redistributions of source code must retain the above copyright notice,\r\n     this list of conditions and the following disclaimer.\r\n   * Redistributions in binary form must reproduce the above copyright\r\n     notice, this list of conditions and the following disclaimer in the\r\n     documentation and/or other materials provided with the distribution.\r\n   * Neither the name of the Graduate School of Informatics, Kyoto\r\n     University, Japan nor the names of its contributors may be used to\r\n     endorse or promote products derived from this software without specific\r\n     prior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\nPOSSIBILITY OF SUCH DAMAGE.\r\n```\r\n\r\n## Download links\r\nIf you use this software, please consider citing the aforementioned paper in any resulting publication.\r\n* Matlab version with test data: tnm-matlab.zip (tested with Matlab 2011b and 2012a. Also compatible with GNU Octave v3.6 + Octave-Forge)\r\n* OpenCV version with test data: tnm-opencv.zip (tested with Debian wheezy + libcv-dev package)\r\n\r\n\r\n# How to use the Matlab version with sample data \r\n\r\n## Usage\r\n\r\nAfter unzipping the downloaded file, you will have the following files in a single directory named \"tnm\".\r\n* `data/input{1,2,3}.png` : Three input images. They are the original pictures WITH lens distortions.\r\n* `data/input{1,2,3}.txt` : Three input data points extracted from `input{1,2,3}.png`. The points are taken from undistorted images.\r\n* `camera.txt` : The intrinsic parameter of the camera.\r\n* `model.txt` : The reference object.\r\n* `demo.m` : A demo program to run our method.\r\n* `tnm.m` : An implementation of our calibration method.\r\n* `sub_p3p.m` : A sub-function called from `tnm.m` to solve P3P problem.\r\n* `sub_tnm_orth.m` : A sub-function called from `tnm.m`.\r\n* `sub_tnm_rt.m` : A sub-function called from `tnm.m`.\r\n* `sub_reproj.m` : To calc reprojection error.\r\n\r\nStart Matlab, and change the working directory to the \"tnm\" directory. Run `demo.m` and you should see the following outputs and a pop-up window that visualizes the results.\r\n```\r\n> demo.m\r\nAverage reprojection error by TNM : 0.353531 pixel.\r\n\r\n==== Parameters by TNM ====\r\nR =\r\n    0.9552   -0.0316   -0.2942\r\n    0.0262    0.9994   -0.0221\r\n    0.2947    0.0134    0.9555\r\nT =\r\n   71.6716\r\n   84.3404\r\n  120.2696\r\nn1 =\r\n    0.2679\r\n    0.0307\r\n   -0.9629\r\nn2 =\r\n    0.4356\r\n    0.0844\r\n   -0.8962\r\nn3 =\r\n   -0.0443\r\n   -0.0112\r\n   -0.9990\r\nd1 =\r\n  386.2302\r\nd2 =\r\n  355.0478\r\nd3 =\r\n  404.7066\r\n```\r\n\r\n## Brief descriptions of the code\r\n\r\n### `tnm.m` : top-level driver\r\n\r\nThe figure below illustrates the measurement model of our method.\r\n\r\n![Geometry](geometry.gif)\r\n\r\nIn this figure, we use the following notations. Notice that $${}^Yx$$ denotes $$x$$ in $$Y$$ coordinate system.\r\n* $$C$$ : camera.\r\n* $$\\pi_j (j=1,2,3)$$ : three mirrors.\r\n* $${}^Cn_j (j=1,2,3)$$ : the normal vector of $$\\pi_j$$.\r\n* $$d_j (j=1,2,3)$$ : the distance from $$C$$ to $$\\pi_j$$.\r\n* $${}^Xp^i (i=1,2,3)$$ : three reference points in the reference object coordinate system.\r\n* $${}^Cp^i (i=1,2,3)$$ : $${}^Xp^i$$ in the camera $$C$$ coordinate system.\r\n* $${}^Cp^i_j (i,j=1,2,3)$$ : Reflection of $${}^Xp^i$$ by $$\\pi_j$$ in the camera $$C$$ coordinate system.\r\n* $$q^i_j (i,j=1,2,3)$$ : 2D projection of $${}^Cp^i_j$$ in the camera $$C$$ image screen.\r\n\r\nThe goal is to estimate the relative rotation $$R$$ and translation $$T$$ between the camera $$C$$ and the reference $$X$$ which satisfy\r\n> $${}^Cp^i = R \\cdot {}^Xp^i + T (i=1,2,3) $$. (1)\r\n\r\nby knowing $$q^i_j (i,j=1,2,3)$$, the projections of $${}^Xp^i$$ observed via three different mirrors $$\\pi_j (j=1,2,3)$$ of unknown positions. The orientation and the position of t\r\nhe mirrors (the distances from the camera to the mirrors) are also estimated as a result.\r\nSo the input / output of the above-mentioned \"tnm.m\" can be expressed as follows.\r\n* tnm.m\r\n  * Input $$q^i_j (i,j=1,2,3)$$ : 2D projections of three reference points observed via three mirrors $$\\pi_j (j=1,2,3)$$.\r\n  * Output $$R, T$$ : The relative posture and position between the camera $$C$$ and the reference $$X$$.~\r\n$${}^Cn_j, d_j (j=1,2,3)$$ : The orientations and distances of the three mirrors $$\\pi_j (j=1,2,3)$$.\r\n\r\n### Sub-functions\r\n\r\nOur mirror-based calibration method consists of the following three steps, and we provide implementations corresponding to them.\r\n\r\n1. `sub_p3p.m`: P3P per mirrored image.\r\n  * Input:\r\n    * $${}^Xp^i (i=1,2,3)$$ : Three reference points, and\r\n    * $$q^i (i)$$ : their projections observed via a mirror $$\\pi$$.\r\n  * Output: Up to 4 possible solutions of $${}^Cp^i$$\r\n2. `sub_tnm_orth.m`: Unique solution selection using an orthogonality constraint.\r\n  * Input: 64 sets of $${}^Cp^i_j (i,j=1,2,3)$$.\r\n  * Output: The set of $${}^Cp^i_j (i,j=1,2,3)$$ which follows the orthogonality constraint best.\r\n3. `sub_tnm_rt.m`: Linear estimation of $$R$$ and $$T$$.\r\n  * Input: $${}^Cp^i_j (i,j=1,2,3)$$.\r\n  * Output: $$R, T, n_j, d_j (j=1,2,3)$$.\r\n\r\nAnd in addition, we use the following sub-function for evaluation purpose.\r\n* `sub_reproj.m`: Reprojection error evaluation\r\n  * Input:\r\n    * $${}^Xp^i (i=1,\\dots)$$ : Any number of reference points.\r\n    * $$q^i_j (i=1,\\dots, j=1,2,3)$$ : The projections of the reference points via mirrors.\r\n    * $$R, T, n_j, d_j (j=1,2,3)$$ : Estimated parameters.\r\n  * Output: Average reprojection error.\r\n\r\n# How to use the OpenCV version with sample data\r\n\r\n## Usage\r\n\r\nAfter unzipping the downloaded file, you will have the following files in a single directory named `./tnm-opencv`.\r\n* `data/input{1,2,3}.png` : Three input images. They are the original pictures WITH lens distortions.\r\n* `data/input{1,2,3}.txt` : Three input data points extracted from input{1,2,3}.png. The points are taken from undistorted images.\r\n* `Makefile` : makefile.\r\n* `demo.cc` : A demo program to run our method.\r\n* `sub_solveP3P.h` : A sub-function called from tnm.h to solve P3P problem.\r\n* `tnm.h` : An implementation of our calibration method.\r\n\r\nThis code requires OpenCV 2.3. We used libcv-dev package in [Debian wheezy](http://packages.debian.org/en/wheezy/libcv-dev). For Debian/Ubuntu, try\r\n```\r\n $ sudo apt-get -f install libcv-dev libcvaux-dev libhighgui-dev g++ make\r\n```\r\nto install requisite libraries and compilation tools, and then exec\r\n```\r\n $ make\r\n```\r\nto compile the code.\r\n\r\nFor Visual C++ on Windows, please simply import `demo.cc`, `sub_solveP3P.h`, and `tnm.h` into a new project, and compile it (you need to setup additional include path and libraries for Op\r\nenCV, of course).\r\n\r\nOnce compiled, run the binary (named `demo`) with no args in the `./tnm-opencv` directory.\r\n```\r\n $ ./demo\r\n loading 'data/input1.txt' = [263.854279, 284.595978;\r\n   380.608337, 284.673645;\r\n   261.375946, 355.315582]\r\n\r\n loading 'data/input2.txt' = [187.462204, 264.845764;\r\n   302.664276, 261.313538;\r\n   183.416656, 338.876984]\r\n\r\n loading 'data/input3.txt' = [393.80719, 301.828278;\r\n   529.568542, 311.569794;\r\n   391.23999, 374.259766]\r\n\r\n loading 'data/model.txt' = [0, 0, 0;\r\n   175, 0, 0;\r\n   0, 100, 0]\r\n\r\n loading 'data/camera.txt' = [487.910797, 0, 324.31308;\r\n   0, 487.558441, 237.003937;\r\n   0, 0, 1]\r\n\r\n\r\n Average reprojection error by TNM : 0.353531 pixels\r\n\r\n ==== Parameters by TNM ====\r\n\r\n R  = [0.9552278293542109, -0.0315692738655991, -0.2941822138995512;\r\n   0.02622804982091903, 0.9994120031779081, -0.02208477544627536;\r\n   0.294706436016986, 0.01338016634873504, 0.9554941589139341]\r\n\r\n T  = [71.67155976406129; 84.34036742140127; 120.2696306131992]\r\n\r\n n1 = [0.2679446927390354; 0.03066392138399924; -0.9629461903753189]\r\n\r\n n2 = [0.4356434955333516; 0.08437398428883026; -0.8961561111629551]\r\n\r\n n3 = [-0.04427539436835728; -0.01119106464381498; -0.9989566805050478]\r\n\r\n d1 = 386.23\r\n\r\n d2 = 355.048\r\n\r\n d3 = 404.707\r\n```\r\n\r\nThis program automatically loads data from `data/input{1,2,3}.txt`, and then outputs the estimated parameters to stdout.\r\n\r\n## Brief descriptions of the code\r\n\r\nThe structure of the code is very straightforward. Please visit the `main()` function in `demo.cc` first. The flow of `main()` is:\r\n\r\n1. load data from files (`model.txt`, `input{1,2,3}.txt`) by `load()` function defined in `demo.cc`.\r\n2. run calibration by `tnm()` function defined in tnm.h. What this function does inside is:\r\n   1. call `sub_solveP3P()` defined in `sub_solveP3P.h` for each input data (= the Matlab function in `tnm-matlab/sub_p3p.m`),\r\n   2. call `sub_tnm_orth()` defined in `tnm.h` (= the Matlab function in `tnm-matlab/sub_tnm_orth.m`), and\r\n   3. call `sub_tnm_rt()` defined in `tnm.h` (= the Matlab function in `tnm-matlab/sub_tnm_rt.m`).\r\n3. run `sub_reproj()` defined in `demo.cc` to evaluate the reprojection error (= the Matlab function in `tnm-matlab/sub_reproj.m`).\r\n\r\nSo to re-use the code for your own project, copy `tnm.h` and `sub_solveP3P.h`, and then use `tnm()` for calibration. To understand how to prepare the data, please consult the `load()` f\r\nunction in `demo.cc`.\r\n\r\n# How to use the code with your own data\r\n\r\nTo calibrate your own system, please follow the process below. In short, update `data/model.txt` and `data/input{1,2,3}.txt`, then run the program again.\r\n\r\n1. Suppose you have a reference object $$X$$ and a camera $$C$$.\r\n   1. The intrinsic parameters of $$C$$ should be provided. You can use OpenCV to estimate them.\r\n2. Capture three images of $$X$$ as $$I_1, I_2, I_3$$ via mirrors $$\\pi_1, \\pi_2, \\pi_3$$ under different poses.\r\n3. Detect three points of $$X$$ for each of the images ($$I_1, I_2, I_3$$).\r\n   1. Here we assume that the images are rectified (undistorted) using the intrinsic parameters before the detection.\r\n   2. If you used a chessboard pattern as $$X$$ and used OpenCV [findChessboardCorners()](http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findch\r\nessboardcorners) to detect it in $$I_1, I_2, I_3$$ automatically, you need to **flip** the detection result because the detector does not account for the observation via mirror.\r\n4. Store the data into `data/model.txt` and `data/input{1,2,3}.txt`.\r\n   1. `data/model.txt` is a line-oriented plain text file each of lines represents the 3D position of a reference point in $$X$$.\r\n```\r\n 0.000000 0.000000 0.000000\r\n 175.000000 0.000000 0.000000\r\n 0.000000 100.000000 0.000000\r\n```\r\n   2. `data/input{1,2,3}.txt` are also line-oriented plain text files, and each of lines represents the 2D projection of the corresponding 3D reference point in `data/model.txt`. For examp\r\nle, the first line below is the projection of the first reference point $$(0,0,0)$$ defined in the first line of `data/model.txt`.\r\n```\r\n 380.608337 284.673645\r\n 263.854279 284.595978\r\n 377.368225 350.688141\r\n```\r\n5. Exec the demo program again, and you will get the result.\r\n\r\n# Contact\r\n* [Shohei NOBUHARA](http://vision.kuee.kyoto-u.ac.jp/~nob/)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}